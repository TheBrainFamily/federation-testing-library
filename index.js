const {
  LocalGraphQLDataSource,
  buildOperationContext,
  buildQueryPlan,
  executeQueryPlan
} = require("@apollo/gateway");
const { addMockFunctionsToSchema } = require("graphql-tools");
const { addResolversToSchema } = require("apollo-graphql");
const { print } = require("graphql");
const {
  buildFederatedSchema,
  composeAndValidate
} = require("@apollo/federation");
const clone = require("clone");
const gql = require("graphql-tag");

function buildLocalService(modules) {
  const schema = buildFederatedSchema(modules);
  return new LocalGraphQLDataSource(schema);
}

function buildRequestContext(variables, context) {
  return {
    cache: undefined,
    context,
    request: {
      variables
    }
  };
}

function prepareProviderService(service) {
  let allTypeNames = [];

  const typeDefsForMockedService = clone(service.typeDefs);

  typeDefsForMockedService.definitions = typeDefsForMockedService.definitions
    .filter(
      d => d.name && d.name.value !== "Query" && d.name.value !== "Mutation"
    )
    .filter(d => d.kind === "ObjectTypeExtension");

  typeDefsForMockedService.definitions.forEach(def => {
    def.kind = "ObjectTypeDefinition";
    allTypeNames.push(def.name.value);

    def.fields = def.fields.filter(f =>
      f.directives.find(d => d.name.value === "external")
    );
    def.fields.forEach(f => {
      f.directives = f.directives.filter(d => d.name.value !== "external");
    });
  });

  if (allTypeNames.length) {
    const typesQueries = allTypeNames.map(n => `_get${n}: ${n}`).join("\n");
    const newTypeDefString = `
        extend type Query {
          ${typesQueries}
        }
        ${print(typeDefsForMockedService)}
      `;

    // I'm doing it like this because otherwise IDE screams at me for an incorrect GraphQL string
    let newTypeDefs = gql`
      ${newTypeDefString}
    `;

    return {
      __provider: {
        typeDefs: newTypeDefs
      }
    };
  }
  return undefined;
}

const setupSchema = serviceOrServices => {
  let services;
  if (!serviceOrServices.length) {
    services = [
      {
        serviceUnderTest: {
          resolvers: serviceOrServices.resolvers,
          typeDefs: serviceOrServices.typeDefs,
          addMocks: serviceOrServices.addMocks
        }
      }
    ];
    const providerService = prepareProviderService(serviceOrServices);
    if (providerService) {
      services.push(providerService);
    }
  } else {
    services = serviceOrServices;
  }

  let serviceMap = {};
  services.forEach(service => {
    let serviceName = Object.keys(service)[0];
    if (!service[serviceName].resolvers) {
      service[serviceName].addMocks = true;
    }
    serviceMap[serviceName] = buildLocalService([service[serviceName]]);
    serviceMap[serviceName].__addMocks__ = service[serviceName].addMocks;
  });

  let mapForComposeServices = Object.entries(serviceMap).map(
    ([serviceName, service]) => ({
      name: serviceName,
      typeDefs: service.sdl()
    })
  );

  let composed = composeAndValidate(mapForComposeServices);

  if (composed.errors && composed.errors.length > 0) {
    throw new Error(JSON.stringify(composed.errors));
  }
  return { schema: composed.schema, serviceMap };
};

function setupMocks(serviceMap, mocks) {
  Object.values(serviceMap).forEach(service => {
    let resolvers = {};
    if (service.__addMocks__) {
      Object.entries(mocks).forEach(([type, value]) => {
        resolvers[type] = {
          __resolveReference() {
            return value();
          }
        };
      });
      addResolversToSchema(service.schema, resolvers);
      addMockFunctionsToSchema({
        schema: service.schema,
        preserveResolvers: true,
        mocks
      });
    }
  });
}

function execute(schema, query, mutation, serviceMap, variables, context) {
  const operationContext = buildOperationContext(schema, query || mutation);
  const queryPlan = buildQueryPlan(operationContext);

  return executeQueryPlan(
    queryPlan,
    serviceMap,
    buildRequestContext(variables, context),
    operationContext
  );
}

function validateArguments(
  services,
  service,
  schema,
  serviceMap,
  query,
  mutation
) {
  if (!(services || service)) {
    if (!schema) {
      throw new Error(
        "You need to pass either services array to prepare your schema, or the schema itself, generated by the setupSchema function"
      );
    }
    if (!serviceMap) {
      throw new Error(
        "You need to pass the serviceMap generated by the setupSchema function along with your schema"
      );
    }
  }
  if (!(query || mutation)) {
    throw new Error("Make sure you pass a query or a mutation");
  }
}

const executeGraphql = ({
  query,
  mutation,
  variables,
  context,
  services,
  mocks = {},
  schema,
  serviceMap,
  service
}) => {
  validateArguments(services, service, schema, serviceMap, query, mutation);

  if (services || service) {
    ({ serviceMap, schema } = setupSchema(services || service));
  }

  setupMocks(serviceMap, mocks);

  return execute(schema, query, mutation, serviceMap, variables, context);
};

module.exports = {
  setupSchema,
  executeGraphql
};
